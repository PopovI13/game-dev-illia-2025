<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realistic Car Game</title>
    <style>
        @import url('https://fonts2.com/css2?family=Inter:wght@400;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            text-align: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: bold;
            color: #fca5a5;
            margin-bottom: 20px;
        }

        #game-container {
            position: relative;
            width: 90%;
            max-width: 400px;
            background-color: #2d3748;
            border-radius: 10px;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.5);
            padding: 15px;
            overflow: hidden; /* Prevents overflow from screen shake */
        }

        canvas {
            background-color: #4a5568;
            border: 2px solid #a0aec0;
            border-radius: 8px;
            display: block;
            width: 100%;
            height: auto;
            aspect-ratio: 9 / 16;
            touch-action: none;
            transition: transform 0.1s ease;
        }
        
        /* CSS for the screen shake effect */
        .shake {
            animation: shake 0.3s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0);
            backface-visibility: hidden;
            perspective: 1000px;
        }

        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }

        #ui-container {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
        }

        #score-display {
            font-size: 1.5rem;
            font-weight: bold;
            color: #90cdf4;
        }

        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(45, 55, 72, 0.95);
            border: 2px solid #a0aec0;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 14px rgba(0, 0, 0, 0.7);
            z-index: 10;
            display: none;
            flex-direction: column;
            gap: 15px;
            width: 80%;
            max-width: 300px;
            animation: fadeIn 0.5s ease-out;
        }

        .message-box h2 {
            font-size: 2rem;
            color: #fca5a5;
            margin: 0;
        }

        .message-box p {
            font-size: 1rem;
            color: #cbd5e0;
            margin: 0;
        }

        .restart-btn {
            background-color: #63b3ed;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 1rem;
            font-weight: bold;
            border-radius: 9999px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        .restart-btn:hover {
            background-color: #4299e1;
            transform: translateY(-2px);
        }

        .controls {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .control-btn {
            background-color: #4a5568;
            color: white;
            border: 2px solid #a0aec0;
            padding: 15px 30px;
            font-size: 1.2rem;
            font-weight: bold;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }

        .control-btn:hover {
            background-color: #6b7280;
            transform: scale(1.05);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
</head>
<body>

    <h1>Road Rage</h1>
    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <div id="messageBox" class="message-box">
            <h2 id="messageTitle">Game Over</h2>
            <p id="messageText">You crashed! Score: <span id="finalScore">0</span></p>
            <button id="restartButton" class="restart-btn">Restart</button>
        </div>
    </div>
    <div id="ui-container">
        <p>Use arrow keys or buttons to move.</p>
        <p id="score-display">Score: 0</p>
        <div class="controls">
            <button id="left-btn" class="control-btn">←</button>
            <button id="right-btn" class="control-btn">→</button>
        </div>
    </div>

    <script>
        window.onload = function() {
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            const scoreDisplay = document.getElementById('score-display');
            const messageBox = document.getElementById('messageBox');
            const finalScoreSpan = document.getElementById('finalScore');
            const messageTitle = document.getElementById('messageTitle');
            const messageText = document.getElementById('messageText');
            const restartButton = document.getElementById('restartButton');
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');

            // Set canvas dimensions based on container
            function resizeCanvas() {
                const container = document.getElementById('game-container');
                canvas.width = container.offsetWidth - 30;
                canvas.height = (canvas.width / 9) * 16;
            }
            window.addEventListener('resize', resizeCanvas);
            resizeCanvas();

            // Tone.js Music and Sound Effects Setup
            let musicLoop = null;
            let crashSynth = null;

            function setupMusic() {
                if (musicLoop) {
                    musicLoop.stop();
                }

                const synth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: {
                        type: 'triangle'
                    },
                    envelope: {
                        attack: 0.2,
                        decay: 0.1,
                        sustain: 0.3,
                        release: 1
                    }
                }).toDestination();
                
                const filter = new Tone.Filter(200, "lowpass").toDestination();
                synth.connect(filter);

                const notes = ["C3", "E3", "G3", "A3"];
                let index = 0;

                musicLoop = new Tone.Loop(time => {
                    const note = notes[index % notes.length];
                    synth.triggerAttackRelease(note, "8n", time);
                    index++;
                }, "4n");

                // Setup crash sound effect
                crashSynth = new Tone.NoiseSynth({
                    volume: -10,
                    noise: { type: "white" },
                    envelope: {
                        attack: 0.001,
                        decay: 0.2,
                        sustain: 0.1,
                        release: 0.3
                    }
                }).toDestination();
            }

            function playSound(type) {
                Tone.start();
                if (type === 'crash' && crashSynth) {
                    crashSynth.triggerAttackRelease("4n");
                }
            }

            let car = {
                x: canvas.width / 2,
                y: canvas.height * 0.8,
                width: 30,
                height: 50,
                speed: 20,
                velocityX: 0,
                tilt: 0,
                maxTilt: 15,
                color: '#ef4444',
                particles: [] // Array to hold smoke trail particles
            };

            let obstacles = [];
            let score = 0;
            let isGameOver = false;
            let obstacleSpeed = 4;
            let lastObstacleTime = 0;
            let obstacleSpawnInterval = 1000; // Increased interval for easier play
            let roadScrollY = 0;
            let fireworks = [];
            let fireworksIntervalId = null;
            const WIN_SCORE = 2000;
            
            // Class for firework particles
            class FireworkParticle {
                constructor(x, y, color) {
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    this.size = Math.random() * 2 + 1;
                    this.speed = Math.random() * 3 + 1;
                    this.angle = Math.random() * 2 * Math.PI;
                    this.vx = Math.cos(this.angle) * this.speed;
                    this.vy = Math.sin(this.angle) * this.speed;
                    this.alpha = 1;
                    this.decay = Math.random() * 0.015 + 0.005;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;
                    this.alpha -= this.decay;
                }

                draw() {
                    ctx.save();
                    ctx.globalAlpha = this.alpha;
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
            
            // Function to draw the road with lane lines
            function drawRoad() {
                const laneWidth = 10;
                const laneGap = 30;
                const laneHeight = 60;
                const totalLaneDistance = laneHeight + laneGap;
                
                ctx.fillStyle = '#6b7280';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Draw lane lines
                ctx.fillStyle = '#e5e7eb';
                const laneX = (canvas.width / 2) - (laneWidth / 2);
                for (let y = -totalLaneDistance; y < canvas.height; y += totalLaneDistance) {
                    ctx.fillRect(laneX, y + roadScrollY, laneWidth, laneHeight);
                }
                
                roadScrollY += obstacleSpeed;
                if (roadScrollY >= totalLaneDistance) {
                    roadScrollY = 0;
                }
            }
            
            // Function to draw the player's car
            function drawPlayerCar(carObj) {
                ctx.save();
                ctx.translate(carObj.x, carObj.y);
                ctx.rotate(carObj.tilt * Math.PI / 180);

                // Body with rounded corners and a shadow
                ctx.beginPath();
                ctx.fillStyle = carObj.color;
                ctx.roundRect(-carObj.width / 2, -carObj.height / 2, carObj.width, carObj.height, 5);
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 10;
                ctx.shadowOffsetX = 5;
                ctx.shadowOffsetY = 5;
                ctx.fill();
                ctx.closePath();

                // Clear shadow for other parts
                ctx.shadowBlur = 0;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;

                // Windows
                ctx.fillStyle = '#6b7280';
                ctx.beginPath();
                ctx.roundRect(-carObj.width / 2 + 5, -carObj.height / 2 + 5, carObj.width - 10, carObj.height * 0.4, 3);
                ctx.fill();
                ctx.closePath();

                // Headlights
                ctx.fillStyle = '#fde047';
                ctx.beginPath();
                ctx.arc(-carObj.width / 2 + 5, carObj.height / 2 - 5, 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(carObj.width / 2 - 5, carObj.height / 2 - 5, 2, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();

                // Wheels
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(-carObj.width / 2 + 2, -carObj.height / 2 + 8, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(carObj.width / 2 - 2, -carObj.height / 2 + 8, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(-carObj.width / 2 + 2, carObj.height / 2 - 8, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(carObj.width / 2 - 2, carObj.height / 2 - 8, 4, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();

                ctx.restore();
            }

            // Function to draw an obstacle car
            function drawObstacleCar(obs) {
                ctx.save();
                ctx.translate(obs.x + obs.width / 2, obs.y + obs.height / 2);

                // Body with rounded corners
                ctx.beginPath();
                ctx.fillStyle = obs.color;
                ctx.roundRect(-obs.width / 2, -obs.height / 2, obs.width, obs.height, 5);
                ctx.fill();
                ctx.closePath();

                // Windows
                ctx.fillStyle = '#6b7280';
                ctx.beginPath();
                ctx.roundRect(-obs.width / 2 + 3, -obs.height / 2 + 3, obs.width - 6, obs.height * 0.4, 2);
                ctx.fill();
                ctx.closePath();

                // Wheels
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(-obs.width / 2 + 2, -obs.height / 2 + 6, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(obs.width / 2 - 2, -obs.height / 2 + 6, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(-obs.width / 2 + 2, obs.height / 2 - 6, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();
                ctx.beginPath();
                ctx.arc(obs.width / 2 - 2, obs.height / 2 - 6, 3, 0, 2 * Math.PI);
                ctx.fill();
                ctx.closePath();

                ctx.restore();
            }

            function generateObstacle() {
                const obstacleWidth = Math.random() * (car.width * 1.5) + 20;
                const obstacleHeight = Math.random() * (car.height * 1.2) + 30;
                const obstacleX = Math.random() * (canvas.width - obstacleWidth);
                const obstacleY = -obstacleHeight;
                const colors = ['#f59e0b', '#10b981', '#3b82f6', '#90cdf4', '#f687b3'];
                const obstacleColor = colors[Math.floor(Math.random() * colors.length)];
                
                const obstacle = {
                    x: obstacleX,
                    y: obstacleY,
                    width: obstacleWidth,
                    height: obstacleHeight,
                    color: obstacleColor,
                };
                
                obstacles.push(obstacle);
            }

            function updateObstacles() {
                for (let i = 0; i < obstacles.length; i++) {
                    let obs = obstacles[i];
                    obs.y += obstacleSpeed;

                    // Check for collision with the car's body
                    if (
                        car.x - car.width / 2 < obs.x + obs.width &&
                        car.x + car.width / 2 > obs.x &&
                        car.y - car.height / 2 < obs.y + obs.height &&
                        car.y + car.height / 2 > obs.y
                    ) {
                        isGameOver = true;
                        endGame(false);
                    }

                    // Remove obstacle if it's off-screen
                    if (obs.y > canvas.height) {
                        obstacles.splice(i, 1);
                        i--;
                    }
                }
            }

            function drawObstacles() {
                for (let obs of obstacles) {
                    drawObstacleCar(obs);
                }
            }

            // --- Smoke Trail Particles ---
            class SmokeParticle {
                constructor(x, y) {
                    this.x = x;
                    this.y = y;
                    this.size = Math.random() * 2 + 1;
                    this.alpha = 1;
                    this.fadeRate = Math.random() * 0.02 + 0.01;
                    this.vy = -0.5; // Slight upward drift
                }

                update() {
                    this.y += this.vy;
                    this.alpha -= this.fadeRate;
                }

                draw() {
                    ctx.save();
                    ctx.globalAlpha = Math.max(0, this.alpha);
                    ctx.fillStyle = `rgba(200, 200, 200, ${this.alpha})`;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }

            function generateParticle() {
                if (car.velocityX !== 0) {
                    const particleCount = 2;
                    for(let i=0; i < particleCount; i++) {
                        const offset = (Math.random() - 0.5) * car.width * 0.8;
                        car.particles.push(new SmokeParticle(car.x + offset, car.y + car.height/2));
                    }
                }
            }

            function updateParticles() {
                for (let i = car.particles.length - 1; i >= 0; i--) {
                    car.particles[i].update();
                    if (car.particles[i].alpha <= 0) {
                        car.particles.splice(i, 1);
                    }
                }
            }

            function drawParticles() {
                for (let particle of car.particles) {
                    particle.draw();
                }
            }

            // --- Other game functions ---
            function updateFireworks() {
                for (let i = 0; i < fireworks.length; i++) {
                    fireworks[i].update();
                    if (fireworks[i].alpha <= 0) {
                        fireworks.splice(i, 1);
                        i--;
                    }
                }
            }

            function drawFireworks() {
                for (let particle of fireworks) {
                    particle.draw();
                }
            }

            function generateFirework() {
                const colors = ['#fde047', '#10b981', '#3b82f6', '#90cdf4', '#fca5a5', '#ffffff'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height * 0.4;
                const particleCount = 50 + Math.random() * 50;
                for (let i = 0; i < particleCount; i++) {
                    fireworks.push(new FireworkParticle(x, y, color));
                }
            }

            function update() {
                if (isGameOver) return;
                
                // Check for win condition
                if (score >= WIN_SCORE) {
                    endGame(true);
                    return;
                }

                // Update car position with velocity
                car.x += car.velocityX;
                car.velocityX *= 0.9;

                // Update car tilt
                car.tilt = car.velocityX / car.speed * car.maxTilt;

                // Clamp car position to stay on screen
                car.x = Math.max(car.width / 2, Math.min(canvas.width - car.width / 2, car.x));
                car.y = Math.max(car.height / 2, Math.min(canvas.height - car.height / 2, car.y));

                // Spawn new obstacles
                const currentTime = Date.now();
                if (currentTime - lastObstacleTime > obstacleSpawnInterval) {
                    generateObstacle();
                    lastObstacleTime = currentTime;
                }
                
                // Increase score and difficulty over time
                score += 1;
                obstacleSpeed = 4 + Math.floor(score / 300) * 0.4; // Reduced obstacle speed increase
                car.speed = 20 + Math.floor(score / 300) * 1.5; // Reduced car speed increase

                updateObstacles();
                updateParticles();
                generateParticle();
            }

            function draw() {
                drawRoad();
                drawParticles();
                drawPlayerCar(car);
                drawObstacles();
                scoreDisplay.textContent = `Score: ${score}`;
            }

            function gameLoop() {
                if (!isGameOver) {
                    update();
                    draw();
                    requestAnimationFrame(gameLoop);
                } else {
                    // Game is over, but we might still be animating fireworks
                    if (messageTitle.textContent.includes("Win")) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        updateFireworks();
                        drawFireworks();
                        requestAnimationFrame(gameLoop);
                    }
                }
            }
            
            function endGame(isWin) {
                isGameOver = true;
                finalScoreSpan.textContent = score;
                messageBox.style.display = 'flex';
                if (isWin) {
                    messageTitle.textContent = "You Win!";
                    messageText.textContent = `You reached the goal! Final Score: ${score}`;
                    if (fireworksIntervalId) clearInterval(fireworksIntervalId);
                    fireworksIntervalId = setInterval(generateFirework, 500);
                } else {
                    playSound('crash');
                    // Add screen shake effect
                    canvas.classList.add('shake');
                    setTimeout(() => {
                        canvas.classList.remove('shake');
                    }, 300);

                    if (fireworksIntervalId) clearInterval(fireworksIntervalId);
                    messageTitle.textContent = "Game Over";
                    messageText.textContent = `You crashed! Score: ${score}`;
                }
            }

            function restartGame() {
                if (fireworksIntervalId) clearInterval(fireworksIntervalId);
                isGameOver = false;
                score = 0;
                obstacleSpeed = 4;
                obstacleSpawnInterval = 1000;
                obstacles = [];
                fireworks = [];
                car.particles = []; // Clear particles
                car.x = canvas.width / 2;
                car.y = canvas.height * 0.8;
                car.velocityX = 0;
                car.tilt = 0;
                roadScrollY = 0;
                messageBox.style.display = 'none';
                canvas.classList.remove('shake'); // Ensure no shake on start

                // Restart audio playback
                Tone.start();
                setupMusic();
                musicLoop.start(0);

                gameLoop();
            }

            restartButton.addEventListener('click', restartGame);
            leftBtn.addEventListener('mousedown', () => car.velocityX = -car.speed);
            rightBtn.addEventListener('mousedown', () => car.velocityX = car.speed);
            leftBtn.addEventListener('mouseup', () => car.velocityX = 0);
            rightBtn.addEventListener('mouseup', () => car.velocityX = 0);
            leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); car.velocityX = -car.speed; });
            rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); car.velocityX = car.speed; });
            leftBtn.addEventListener('touchend', () => car.velocityX = 0);
            rightBtn.addEventListener('touchend', () => car.velocityX = 0);

            // Keyboard Controls
            document.addEventListener('keydown', (e) => {
                const acceleration = 2.0;
                if (e.key === 'ArrowLeft') {
                    car.velocityX -= acceleration;
                } else if (e.key === 'ArrowRight') {
                    car.velocityX += acceleration;
                }
            });

            // Touch Controls for mobile
            let touchStartX = 0;

            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
            });

            canvas.addEventListener('touchmove', (e) => {
                const touchX = e.touches[0].clientX;
                const deltaX = touchX - touchStartX;
                car.velocityX = deltaX * 0.8;
                touchStartX = touchX;
                e.preventDefault();
            });

            canvas.addEventListener('touchend', () => {
                car.velocityX = 0;
            });

            // Start the game loop
            restartGame();
        };
    </script>
</body>
</html>
