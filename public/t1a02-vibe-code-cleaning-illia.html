<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lightning McQueen: Jumper</title>
</head>
<body>

<h1>Lightning McQueen: Jumper</h1>
<canvas id="gameCanvas" width="800" height="400"></canvas>
<button id="restartButton" style="display:none">Play Again</button>
<div>Press <strong>Spacebar</strong> to JUMP! Collect trophies!</div>

<script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const restartButton = document.getElementById('restartButton');
  const ROAD_HEIGHT = 50;
  const GROUND_Y = canvas.height - ROAD_HEIGHT;

  const player = {
    x: 50, y: GROUND_Y - 60, width: 70, height: 60,
    velocityY: 0, gravity: 0.8, jumpPower: -18, isJumping: false
  };

  let entities = [], clouds = [], backgroundLayers = [];
  let score = 0, highScore = 0, gameSpeed = 5, gameOver = false, spawnTimer = 0;

  function drawPlayer() {
    ctx.fillStyle = 'red';
    ctx.fillRect(player.x, player.y, player.width, player.height - 15);
    ctx.fillStyle = 'darkred';
    ctx.fillRect(player.x + 10, player.y - 15, player.width - 20, 15);
    ctx.fillStyle = 'black';
    ctx.beginPath();
    ctx.arc(player.x + 15, player.y + player.height - 15, 10, 0, Math.PI * 2);
    ctx.arc(player.x + player.width - 15, player.y + player.height - 15, 10, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.moveTo(player.x + 15, player.y + 15);
    ctx.lineTo(player.x + 40, player.y + 15);
    ctx.lineTo(player.x + 25, player.y + 25);
    ctx.lineTo(player.x + 50, player.y + 25);
    ctx.lineTo(player.x + 20, player.y + 40);
    ctx.lineTo(player.x + 35, player.y + 28);
    ctx.lineTo(player.x + 15, player.y + 28);
    ctx.closePath();
    ctx.fill();
  }

  function drawBackground() {
    backgroundLayers.forEach(layer => {
      ctx.fillStyle = layer.color;
      layer.elements.forEach(el => {
        ctx.beginPath();
        if (layer.type === 'mountains') {
          ctx.moveTo(el.x, GROUND_Y);
          ctx.lineTo(el.x + el.width / 2, GROUND_Y - el.height);
          ctx.lineTo(el.x + el.width, GROUND_Y);
        } else if (layer.type === 'hills') {
          ctx.arc(el.x, GROUND_Y, el.width, Math.PI, 0);
        }
        ctx.closePath();
        ctx.fill();
      });
    });
  }

  function drawRoad() {
    ctx.fillStyle = '#333';
    ctx.fillRect(0, GROUND_Y, canvas.width, ROAD_HEIGHT);
    ctx.fillStyle = 'yellow';
    for (let i = -gameSpeed * spawnTimer % 40; i < canvas.width; i += 40) {
      ctx.fillRect(i, GROUND_Y + ROAD_HEIGHT / 2 - 2, 20, 4);
    }
  }

  function drawEntities() {
    entities.forEach(e => {
      if (e.type === 'pothole') {
        ctx.fillStyle = '#A0522D';
        ctx.fillRect(e.x, e.y, e.width, e.height);
      } else if (e.type === 'cone') {
        ctx.fillStyle = 'orange';
        ctx.beginPath();
        ctx.moveTo(e.x + e.width / 2, e.y);
        ctx.lineTo(e.x, e.y + e.height);
        ctx.lineTo(e.x + e.width, e.y + e.height);
        ctx.closePath();
        ctx.fill();
      } else if (e.type === 'trophy') {
        ctx.fillStyle = '#FFD700';
        ctx.fillRect(e.x, e.y, e.width, e.height);
        ctx.fillRect(e.x + e.width / 4, e.y - e.height / 2, e.width / 2, e.height / 2);
      }
    });
  }

  function drawClouds() {
    ctx.fillStyle = 'rgba(255,255,255,0.8)';
    clouds.forEach(c => {
      ctx.beginPath();
      ctx.arc(c.x, c.y, c.size, 0, Math.PI * 2);
      ctx.arc(c.x + c.size * 0.8, c.y, c.size * 0.8, 0, Math.PI * 2);
      ctx.arc(c.x - c.size * 0.8, c.y, c.size * 0.7, 0, Math.PI * 2);
      ctx.fill();
    });
  }

  function drawScore() {
    ctx.font = '24px Arial';
    ctx.fillStyle = '#FFF';
    ctx.textAlign = 'left';
    ctx.fillText(`Score: ${Math.floor(score)}`, 20, 40);
    ctx.textAlign = 'right';
    ctx.fillText(`High Score: ${Math.floor(highScore)}`, canvas.width - 20, 40);
  }

  function updatePlayer() {
    player.velocityY += player.gravity;
    player.y += player.velocityY;
    if (player.y > GROUND_Y - player.height) {
      player.y = GROUND_Y - player.height;
      player.velocityY = 0;
      player.isJumping = false;
    }
  }

  function updateBackground() {
    backgroundLayers.forEach(layer => {
      layer.elements.forEach(el => el.x -= gameSpeed * layer.speed);
      if (layer.elements[0].x < -layer.elements[0].width) {
        const el = layer.elements.shift();
        const last = layer.elements[layer.elements.length - 1];
        el.x = last.x + last.width + layer.gap;
        layer.elements.push(el);
      }
    });
  }

  function updateEntities() {
    spawnTimer++;
    if (spawnTimer > 80 + Math.random() * 120) {
      const rand = Math.random();
      if (rand < 0.5) {
        entities.push({ type: 'pothole', x: canvas.width, y: GROUND_Y - 15, width: 30, height: 15 });
      } else if (rand < 0.8) {
        entities.push({ type: 'cone', x: canvas.width, y: GROUND_Y - 40, width: 30, height: 40 });
      } else {
        entities.push({ type: 'trophy', x: canvas.width, y: GROUND_Y - 80, width: 25, height: 25 });
      }
      spawnTimer = 0;
    }
    entities.forEach(e => e.x -= gameSpeed);
  }

  function updateClouds() {
    if (clouds.length < 5 && Math.random() < 0.01) {
      clouds.push({ x: canvas.width + 50, y: Math.random() * (canvas.height / 2), size: Math.random() * 15 + 15 });
    }
    clouds.forEach(c => c.x -= gameSpeed * 0.4);
    clouds = clouds.filter(c => c.x > -100);
  }

  function checkCollisions() {
    entities = entities.filter(e => {
      const hit = player.x < e.x + e.width && player.x + player.width > e.x &&
                  player.y < e.y + e.height && player.y + player.height > e.y;
      if (hit) {
        if (e.type === 'trophy') {
          score += 50;
          return false;
        } else {
          gameOver = true;
        }
      }
      return e.x + e.width > 0;
    });
  }

  function showGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    if (score > highScore) highScore = score;
    ctx.font = '50px Arial';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 30);
    ctx.font = '24px Arial';
    ctx.fillText(`Final Score: ${Math.floor(score)}`, canvas.width / 




 
