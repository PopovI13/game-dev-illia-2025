<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Async Evolution – Functional Upgrade</title>
<style>
    body { font-family: system-ui, sans-serif; margin: 20px; }
    h1 { text-align: center; }
    textarea { width: 100%; padding: 8px; font-size: 16px; }
    button { padding: 10px 15px; margin: 3px; }
    #results { 
        white-space: pre-wrap; 
        background:#f7f7f7; 
        padding:12px; 
        border:1px solid #ccc; 
        border-radius:6px;
        max-height:450px;
        overflow-y:auto;
    }
    img.preview {
        max-width: 300px;
        border-radius: 8px;
        margin-top: 10px;
        border: 1px solid #aaa;
    }
    .header { font-weight: bold; }
</style>
</head>

<body>

<h1>⚡ Async Evolution – Functional Upgrade Demo</h1>
<p>Now includes: image preview, timing metrics, response headers, validation, and more.</p>

<label><b>API URL:</b></label>
<textarea id="api-url" rows="2">https://randomfox.ca/floof/</textarea>

<label>
    <input type="checkbox" id="nocache"> Prevent caching (add ?nocache=timestamp)
</label><br><br>

<button onclick="xhrFetch()">1. Run XHR</button>
<button onclick="promiseFetch()">2. Run Promises (.then)</button>
<button onclick="awaitFetch()">3. Run Async/Await</button>
<button onclick="clearOut()">Clear Output</button>

<div id="results">Output Cleared...</div>

<script>
const out = document.getElementById("results");

/* Utility logging */
function log(msg) {
    out.innerHTML += msg + "\n";
    out.scrollTop = out.scrollHeight;
}

function clearOut() {
    out.innerHTML = "Output Cleared...\n";
}

/* --- Build final URL --- */
function getUrl() {
    let url = document.getElementById("api-url").value.trim();
    const nocache = document.getElementById("nocache").checked;

    try { new URL(url); } 
    catch { throw new Error("Invalid URL"); }

    if (nocache) url += (url.includes("?") ? "&" : "?") + "nocache=" + Date.now();
    return url;
}

/* --- Render JSON + Image if present --- */
function renderData(data) {
    out.innerHTML += "<pre>" + JSON.stringify(data, null, 2) + "</pre>";

    const imgUrl = findImageUrl(data);
    if (imgUrl) {
        out.innerHTML += `<img class="preview" src="${imgUrl}" alt="preview image">`;
    }
}

/* Detect image URL inside JSON */
function findImageUrl(obj) {
    for (const key in obj) {
        if (typeof obj[key] === "string" && obj[key].match(/\.(jpg|jpeg|png|gif|webp)$/i)) {
            return obj[key];
        }
    }
    return null;
}

/* -------------------------------
   Shared Execution Engine
--------------------------------*/
async function runRequest(fetchFn, label) {
    clearOut();
    log(`--- ${label} Started ---`);

    let url;
    try {
        url = getUrl();
    } catch (e) {
        log("❌ " + e.message);
        return;
    }

    const start = performance.now();
    log("URL: " + url);

    try {
        const response = await fetchFn(url);
        const time = (performance.now() - start).toFixed(1);

        log(`Status: ${response.status} ${response.statusText}`);
        log(`Time: ${time} ms`);

        // Content length
        const size = response.headers.get("content-length");
        if (size) log(`Size: ${size} bytes`);

        // Display response headers
        log("\n-- Response Headers --");
        response.headers.forEach((v, k) => log(`${k}: ${v}`));

        log("\n-- JSON Body --");
        const data = await response.json();
        renderData(data);

        log("\n✔ Completed using " + label);
    } 
    catch (err) {
        log("\n❌ Error: " + err.message);
    }
}

/* -------------------------------
   1. XHR Fetch
--------------------------------*/
function xhrFetch() {
    runRequest((url) => {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", url);
            xhr.onload = () => {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(new Response(xhr.responseText, {
                        status: xhr.status,
                        statusText: xhr.statusText,
                        headers: new Headers()
                    }));
                } else reject(new Error("XHR HTTP " + xhr.status));
            };
            xhr.onerror = () => reject(new Error("Network error"));
            xhr.send();
        });
    }, "XHR");
}

/* -------------------------------
   2. Promise Fetch
--------------------------------*/
function promiseFetch() {
    runRequest(
        (url) => fetch(url).then(r => {
            if (!r.ok) throw new Error("HTTP " + r.status);
            return r;
        }),
        "Promises (.then)"
    );
}

/* -------------------------------
   3. Async/Await Fetch
--------------------------------*/
function awaitFetch() {
    runRequest(
        async (url) => {
            const r = await fetch(url);
            if (!r.ok) throw new Error("HTTP " + r.status);
            return r;
        },
        "Async/Await"
    );
}
</script>

</body>
</html>
